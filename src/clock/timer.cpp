#include <cassert>

#include "longClockTimer.h"

#include "../drivers/compareRegister.h"



/*
 * Timer
 *
 *
 */


namespace {
/*
 * RTC device has three compare registers, each generating event/interrupt.
 * All the events are handled by one ISR (RTC0_ISRHandler)
 * This class owns a facade on the counter registers, and a knows a callback for each's interrupt.
 * Callback is also used as a flag for 'started'
 */
TimerCallback timerCallback[3];
bool _expired[3];
CompareRegister compareRegisters[3];


// TODO this could be done as initializers, not at runtime and would then be in ROM?
/*
 * Init the facades to the RTCTimers, i.e. the addresses and masks of each compare register.
 *
 * This does not guarantee the state of the hw compare registers
 * (but typically, all are in POR reset state i.e. disabled.)
 */
void initCompareRegs() {
	// This is expanded because the hw constants are defined by unparameterized macros
	// Parameters of compareRegisters are fixed by hw design
	compareRegisters[0].init(
			NRF_RTC_EVENT_COMPARE_0,
			//RTC_EVTEN_COMPARE0_Msk,
			NRF_RTC_INT_COMPARE0_MASK,
			0	// index
	);
	compareRegisters[1].init(
			NRF_RTC_EVENT_COMPARE_1,
			//RTC_EVTEN_COMPARE1_Msk,
			NRF_RTC_INT_COMPARE1_MASK,
			1	// index
	);
	compareRegisters[2].init(
			NRF_RTC_EVENT_COMPARE_2,
			//RTC_EVTEN_COMPARE2_Msk,
			NRF_RTC_INT_COMPARE2_MASK,
			2	// index
	);

	timerCallback[0] = nullptr;
	timerCallback[1] = nullptr;
	timerCallback[2] = nullptr;

	_expired[0] = false;
	_expired[1] = false;
	_expired[2] = false;
}

/*
 * A Timer is built upon a CompareRegister.
 * Since a CompareRegister has limitations,
 * do more here to accommodate the limitations.
 * This is a concern of the Timer, not of the CompareRegister.
 *
 * Should be no references to platform here.
 */
void configureCompareRegisterForTimer(TimerIndex index, OSTime timeout){
	// require event disabled?

	OSTime beforeCounter = LongClockTimer::osClockNowTime();
	/*
	 * Interrupts are not disabled.
	 * The counter may continue running while servicing interrupts.
	 * Thus currentCount can get stale, and we must accommodate.
	 */
	/*
	 * RTC0 is 24-bit timer.
	 * Value is computed in 32-bit math.
	 * We don't need need modulo 24-bit math (mask with 0xFFFFFF)
	 * because the HW of the comparator only reads the lower 24-bits (effectively masks with 0xFFFFFF).
	 * But the values set and get might have ones in upper 8-bits.
	 * Can only assert(nrf_rtc_cc_get() == newCompareValue);
	 */
	unsigned int newCounterValue = beforeCounter + timeout;

	/*
	 * Setting timeout and enabling interrupt must be close together,
	 * else counter exceeds compare already, and no interrupt till much later after counter rolls over.
	 */
	compareRegisters[index].set(newCounterValue);

	OSTime afterCounter = LongClockTimer::osClockNowTime();

	/*
	 * If newCounterValue is not far in the future, CompareRegister will not generate event (or interrupt)
	 * (or it will be one Counter full late) because of HW limitations.
	 *
	 * Compare to NRF_SDK app_timer.c
	 */
	if (((afterCounter - beforeCounter) +LongClockTimer::MinTimeout ) > timeout) {
		/*
		 * CompareRegister might not generate event.
		 * It might (and then this will be repeated/superfluous, but not undone.)
		 */
		// Mark the timer expired already (the small timeout is already over.)
		LongClockTimer::expire(index);
		// Generate an interrupt so that the ISR will run, see the expired timer, and handle it.
		Nvic::pendRTC0Interrupt();
	}
	else {
		/*
		 * Guaranteed that CompareRegister will generate event and interrupt.
		 */
	}

	// TODO where does this go?????????

	// Compare match must not have happened yet, else no interrupt.
	// Since interrupt from compare not enabled yet.
	compareRegisters[index].enableInterrupt();


	/*
	 * Assert: an event and interrupt have been generated already
	 * OR they WILL be generated by the HW.
	 * Most importantly, the ARM EventRegister is OR will be set,
	 * else a subsequent sleep may sleep forever.
	 */
	/*
	 * There is no race to return here.
	 * The caller's continuation is often: sleep until interrupt.
	 * The interrupt can occur at any time here.
	 * The caller must sleep by first WFE (without clearing EventRegister), and since the event might already be set, won't sleep.
	 * The interrupt typically COULD come in as little as 3 ticks, or 3*30 = 90uSec, which allows about 1440 instructions.
	 */
}

}






void LongClockTimer::timerISR() {
	// Source events are "compare register matched counter"


	// Handle all compare regs: 0-1
	if ( compareRegisters[First].isEvent() ) {
		expire(First);
	}
	if ( compareRegisters[Second].isEvent() ) {
		expire(Second);
	}


	// TODO ???? Check for interrupt without events,
	// i.e. isTimerExpired(index) for short timeout

	if (isExpired(First)) {
		handleExpiration(First);
	}
	else {
		/*
		 * First Timer is unique: used for a sleep loop.
		 * If it is active, it will have woken by whatever event generate this interrupt.
		 * Pass the callback the reason for wake, so it can sleep again.
		 */
		if ( LongClockTimer::isTimerStarted(First) ) {
			timerCallback[First](OverflowOrOtherTimerCompare);
		}
	}
	if (isExpired(Second)) { handleExpiration(Second); }
	// User of second timer doesn't sleep on it.

}


void LongClockTimer::initTimers() {
	initCompareRegs();
}

/*
 * This must be kept short.
 * The timeout could be as little as 3 ticks, or 3*30 = 90uSec, which allows about 1440 instructions.
 */
void LongClockTimer::startTimer(
		TimerIndex index,
		OSTime timeout,
		TimerCallback aTimeoutCallback){
	/*
	 * These assertions do not need be short to prevent sleep forever.
	 * But these assertions do affect the accuracy of the timeout
	 * (the more time we spend here, the later the real timeout will occur
	 * after the time for which the timeout was calculated.
	 */
	assert(timeout < MaxTimeout);
	assert(timeout >= MinTimeout);
	assert(index < CountTimerInstances);
	// assert RTC0_IRQ enabled (enabled earlier for Counter, and stays enabled.

	// Not legal to start Timer already started and not timed out or canceled.
	if (isTimerStarted(index)) {
		assert(false);
		return;	// No error result, must be tested with assertions enabled.
	}

	timerCallback[index] = aTimeoutCallback;
	unexpire(index);

	configureCompareRegisterForTimer(index, timeout);
	// Timer may already be expired, interrupt generated, and callback called
}

bool LongClockTimer::isTimerStarted(TimerIndex index) {
	return ! (timerCallback[index] == nullptr);
}



void LongClockTimer::expire(TimerIndex index) { _expired[index] = true; }
void LongClockTimer::unexpire(TimerIndex index) { _expired[index] = false; }
bool LongClockTimer::isExpired(TimerIndex index) { return _expired[index]; }
void LongClockTimer::handleExpiration(TimerIndex index) {
	// Callback with reason: TimerExpired
	// TODO not the correct reason
	timerCallback[index](SleepTimerCompare);	// call callback
	LongClockTimer::cancelTimer(index);
}



void LongClockTimer::cancelTimer(TimerIndex index){
	/*
	 * Legal to cancel Timer that has not been started.
	 * Legal to call from IRQ or main thread.
	 *
	 * Possible race: Timer IRQ may expire in the middle of this,
	 * so whatever flag the Timer sets may be set even after this is called.
	 *
	 * We clear compare reg event, so it would not be set in a race.
	 */
	compareRegisters[index].disableInterrupt();
	timerCallback[index] = nullptr;
	compareRegisters[index].clearEvent();
	/*
	 * One-shot: assert:
	 * - compare interrupt is disabled.
	 * - compare event is cleared
	 * - compare event is disabled
	 * - callback is cleared
	 * Counter continues and compare reg still set, but it can't fire.
	 */
}
